# 面向对象程序设计

### 学习总结

#### 1. **动态绑定**
- **定义**：动态绑定是指在运行时决定调用哪个函数的过程，通常通过虚函数实现。
- **实现**：使用基类指针或引用指向派生类对象，以实现运行时多态性。

#### 2. **指针和引用的必要性**
- **避免对象切片**：使用指针或引用可以避免对象切片，确保派生类的完整信息得以保留。

#### 3. **虚函数与默认实参**
- 虚函数可以与默认实参一起使用，但注意，如果在派生类中重写了函数，默认实参将以派生类的参数为准。

#### 4. **基类参数传递派生类**
- 基类函数接受基类类型参数时，可以传入派生类对象，因为派生类是基类的扩展。

#### 5. **切片问题**
- 使用基类指针或引用可以避免对象切片，确保派生类特性和行为得以保留。

#### 6. **虚析构函数的必要性**
- 在基类中定义虚析构函数，确保派生类的析构函数在对象删除时被正确调用，避免资源泄漏。

#### 7. **派生类继承的内容**
- 派生类继承基类的成员变量和非私有成员函数，支持多态性。

#### 8. **访问基类的普通函数**
- 派生类对象可以调用基类的`public`和`protected`成员函数，但无法访问`private`成员函数。

#### 9. **抽象类（接口类）的作用**
- 抽象类定义了一个接口，强制派生类实现特定功能，实现多态性和代码复用，提高代码的可维护性。

#### 10. **虚函数的定义**
- 虚函数应在基类中定义，普通虚函数有默认实现，纯虚函数要求派生类实现。

#### 11. **派生类访问基类私有成员**
- **公有/受保护成员函数**：基类可以提供公有或受保护的成员函数供派生类访问私有成员。
- **友元类**：派生类可以作为基类的友元类，从而直接访问基类的私有成员。
- **组合**：通过组合的方式，派生类可以间接访问基类的私有成员。

## 问题

代码：

```cpp
static bool compare(const std::shared_ptr<Quote>& lhs, 
                    const std::shared_ptr<Quote>& rhs) {
    return lhs->isbn() < rhs->isbn();
}
std::multiset<std::shared_ptr<Quote>, decltype(&compare)> items{&compare};
```

自定义比较函数

`set`，`map`这种需要自定义比较规则的时候，传入的应该是可调用的对象

例如新建类，或者类里面重构，并传入这个类。

如果是普通的函数，需要传入这个函数指针，并指名函数指针的类型，避免类型混淆（特别是在运用模板中），同时还需要在后面添加一个实例

而通过类的对象传参，则不需要在后面添加这个实例。

如果普通函数不添加这个实例，则容器在初始化构造的时候，调用的还是默认的比较函数，容器需要一个实例去初始化。

```cpp
struct compare {
    bool operator()(const std::shared_ptr<Quote>& lhs, 
                    const std::shared_ptr<Quote>& rhs) const {
        return lhs->isbn() < rhs->isbn(); // 按 ISBN 排序
    }
};
std::multiset<std::shared_ptr<Quote>,compare> items；
```

上述例子就不需要指定函数指针，也不需要添加实例参数。
